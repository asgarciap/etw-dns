#include "DnsSensor.h"
#include <set>
#include <algorithm>
#include <functional>
#include <psapi.h>

#pragma comment(lib, "psapi.lib")

static const GUID DNSClientProviderGuid =
{ 0x1C95126E, 0x7EEA, 0x49A9, {0xA3, 0xFE, 0xA3, 0x78, 0xB0, 0x3D, 0xDB, 0x4D } };

DnsSensor::DnsSensor() : WinETWSensor((LPWSTR) L"Microsoft-Windows-DNS-Client", DNSClientProviderGuid)
{
    _Stats.DomainCounter.clear();
    _Stats.ProcessCounter.clear();
    _Stats.TotalQueries = 0;
}

void DnsSensor::eventReceived(PEVENT_RECORD evt)
{
    wprintf(L"Received Event on DNS Sensor\n");
    wprintf(L"Generated By ProcessId: %u\n", evt->EventHeader.ProcessId);
    PBYTE value = NULL;
    if (getPropertyValue(evt, (LPWSTR)L"QueryName", &value))
    {
        std::unique_lock<std::mutex> lock(_Lock);
        _Stats.TotalQueries++;
        std::wstring domain;
        domain.assign((LPWSTR)value);
        std::wstring process(getProcessName(evt->EventHeader.ProcessId));
        _Stats.DomainCounter[domain]++;
        _Stats.ProcessCounter[process]++;
        wprintf(L"QueryName: %s\n", (LPWSTR) value);
        free(value);
    }

    if (getPropertyValue(evt, (LPWSTR)L"QueryType", &value))
    {
        wprintf(L"QueryType: %d\n", *(PBYTE) value);
        free(value);
    }
}

std::wstring DnsSensor::getProcessName(ULONG pid)
{
    HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (h)
    {
        TCHAR Buffer[MAX_PATH];
        GetModuleFileNameEx(h, 0, Buffer, MAX_PATH);
        CloseHandle(h);
        std::wstring name;
        wchar_t* moduleNameOnly = wcsrchr(Buffer, L'\\') + 1;
        name.assign(moduleNameOnly);
        return name;
    }
    return L"[PID: "+std::to_wstring(pid)+L"]";
}

std::wstring DnsSensor::getInfo()
{
    std::unique_lock<std::mutex> lock(_Lock);
    std::wstring info;
    info = L"DNS Sensor Info\n";
    info.append(L"{\n");
    info.append(L"\tTotal Queries Received: "+std::to_wstring(_Stats.TotalQueries) + L"\n");
    info.append(L"\tTotal Process Generating Queries: " + std::to_wstring(_Stats.ProcessCounter.size()) + L"\n");
    info.append(L"\tTOP Most Queried Domains:\n");

    // Sort DomainCounter Map
    // Stolen from here: https://thispointer.com/how-to-sort-a-map-by-value-in-c/
    // TODO improves sorting mechanism
    typedef std::function<bool(std::pair<std::wstring, UINT64>, std::pair<std::wstring, UINT64>)> Comparator;
    Comparator compFunctor =
        [](std::pair<std::wstring, UINT64> elem1, std::pair<std::wstring, UINT64> elem2)
    {
        if(elem1.second != elem2.second)
            return elem1.second > elem2.second;

        return elem1.first > elem2.first;
    };
    std::set<std::pair<std::wstring, UINT64>, Comparator> topDomains(
        _Stats.DomainCounter.begin(), _Stats.DomainCounter.end(), compFunctor);
    USHORT i = 0;
    for (std::pair<std::wstring, UINT64> domain : topDomains)
    {
        long double fraction = _Stats.TotalQueries > 0.f ? (long double)domain.second / (long double)_Stats.TotalQueries : 0.0f;
        int perct = fraction * 100;
        info.append(L"\t\t");
        info.append(std::to_wstring(perct)+L"% - ");
        info.append(domain.first);
        info.append(L" : " + std::to_wstring(domain.second) + L"\n");
        i++;
        if (i == 10) break;
    }

    info.append(L"\tTOP Most Active Process:\n");
    std::set<std::pair<std::wstring, UINT64>, Comparator> topProcess(
        _Stats.ProcessCounter.begin(), _Stats.ProcessCounter.end(), compFunctor);
    USHORT k = 0;
    for (std::pair<std::wstring, UINT64> process : topProcess)
    {
        long double fraction = _Stats.TotalQueries > 0.f ? (long double)process.second / (long double)_Stats.TotalQueries : 0.0f;
        int perct = fraction * 100;
        info.append(L"\t\t");
        info.append(std::to_wstring(perct) + L"% - ");
        info.append(process.first);
        info.append(L" : " + std::to_wstring(process.second) + L"\n");
        k++;
        if (k == 10) break;
    }

    info.append(L"}\n");
    return info;
}
